
-------------------------------------------------------------------------------
--
-- Copyright (c) 2012 by BARCO - SILEX. All Rights reserved.
--
-- Project     :  BA317
-- Part        :  Memory controller
-- File        :  SdramPhyUltrascale_0.vhd
-- Author      :  Simon Wouters (SIMWO)
-- Purpose     :  Xilinx Ultrascale Phy Wrapper supporting both DDR3 and DDR4
-- Limitations :
--
-------------------------------------------------------------------------------

-------------------------------------------------------------------------------
-- C O M P O N E N T     P A C K A G E
-------------------------------------------------------------------------------
library IEEE;
use ieee.std_logic_1164.all;
use ieee.std_logic_arith.all;
use ieee.std_logic_unsigned.all;
use ieee.std_logic_misc.all;

package SdramPhyUltrascale_0Component_1 is
   component SdramPhyUltrascale_0_1 is
   generic(
      c_ResetLevel      : std_logic;
      c_useSRstNotARst  : boolean := true;
      c_BankWidth       : integer;
      c_BankGroupWidth  : integer;
      c_NbChipSelect    : integer;
      c_NbCke           : integer;
      c_DataWidth       : integer;
      c_NbClkPairs      : integer;
      c_PhysAddrWidth   : integer;
      c_DataRate        : integer;
      c_PingPongPhy     : integer;
      c_CkeShared       : integer := 0;
      c_DataBufAdrWidth : integer;
      c_OdtWidth        : integer;
      c_DmWidth         : integer;
      c_DqsWidth        : integer;
      c_DDR             : integer;
      c_DataCmdSlot_0   : integer := 0;  -- Slot Number for Data Commands (Read/Write)
      c_NoDataCmdSlot_0 : integer := 0;  -- Slot Number for Non Data Commands (Active,Refresh)
      c_DataCmdSlot_1   : integer := 0;  -- Slot Number for Data Commands (Read/Write)
      c_NoDataCmdSlot_1 : integer := 0;  -- Slot Number for Non Data Commands (Active,Refresh)
      -- The following parameters are only used for the behavioral phy model
      c_PhyCmdLatency   : integer := 20;
      c_PhyRdLatency    : integer := 22;
      c_BurstLength     : integer;
      c_Registered      : integer;
      c_CASLatency      : integer;
      c_CWLLatency      : integer;
      c_tCK             : integer;
      c_tWR             : integer;
      c_tRFC            : integer;
      c_tRPA            : integer;
      c_DisableDQSn     : integer;
      c_ClkinPeriodMmcm   : integer;
      c_ClkfboutMultMmcm  : integer;
      c_DivclkDivideMmcm  : integer;
      c_Clkout0DivideMmcm : integer;
      c_Clkout1DivideMmcm : integer;
      c_Clkout2DivideMmcm : integer;
      c_SysClkType        : string
      );
   port(
      -- Clock and reset (input to PHY)
      c0_sys_clk_p      : in std_ulogic := '0';      -- Phy differential clock input
      c0_sys_clk_n      : in std_ulogic := '0';      -- Phy differential clock input
      c0_sys_clk_i      : in std_ulogic := '0';      -- Phy no buffer clock input
      sys_rst           : in std_ulogic := '0';      -- Phy reset

      -- Clock and reset (output from PHY to controller/user logic)
      Clk               : out std_ulogic;         -- Controller clock
      sRst              : out std_ulogic;         -- Controller reset
      sRst_o            : out std_ulogic;         -- Controller reset (external to rest of design)
      Clk_2x            : out std_ulogic := '0';  -- Clk_2x   (addn_ui_clkout1 generated by PHY MMCM)
      UsrClk            : out std_ulogic := '0';  -- User Clk (addn_ui_clkout2 generated by PHY MMCM)

      -- Calibration control
      CalibDone         : out std_ulogic;
      DoRIU             : in  std_ulogic;
      Fail_wrDataEn     : out std_logic_vector(c_PingPongPhy-1 downto 0);

      -- From Controller
      SdramCKE          : in  std_logic_vector((c_PingPongPhy-c_CkeShared)*c_DataRate/2-1 downto 0);
      SdramACTn         : in  std_logic_vector(c_DataRate*c_PingPongPhy/2                -1 downto 0) := (others => '0');
      SdramCSn          : in  std_logic_vector(c_DataRate*c_PingPongPhy/2*c_NbChipSelect -1 downto 0);
      SdramRASn         : in  std_logic_vector(c_DataRate*c_PingPongPhy/2                -1 downto 0) := (others => '0');
      SdramCASn         : in  std_logic_vector(c_DataRate*c_PingPongPhy/2                -1 downto 0) := (others => '0');
      SdramWEn          : in  std_logic_vector(c_DataRate*c_PingPongPhy/2                -1 downto 0) := (others => '0');
      SdramODT          : in  std_logic_vector(c_DataRate*c_PingPongPhy/2                -1 downto 0) := (others => '0');
      SdramBank         : in  std_logic_vector(c_DataRate*c_PingPongPhy/2*c_BankWidth    -1 downto 0);
      SdramAddr         : in  std_logic_vector(c_DataRate*c_PingPongPhy/2*c_PhysAddrWidth-1 downto 0);
      SdramWrData       : in  std_logic_vector(c_DataRate                *c_DataWidth    -1 downto 0);
      SdramWrMask       : in  std_logic_vector(c_DataRate                *c_DmWidth      -1 downto 0);
      SdramWrEn         : in  std_logic_vector(           c_PingPongPhy                  -1 downto 0);
      SdramRdEn         : in  std_logic_vector(           c_PingPongPhy                  -1 downto 0);
      SdramCmd          : in  std_logic_vector(           c_PingPongPhy  *3              -1 downto 0);
      SdramSlot         : in  std_logic_vector(           c_PingPongPhy  *2              -1 downto 0);

      -- To Controller
      RdDataValid       : out std_logic_vector(           c_PingPongPhy                  -1 downto 0);
      SdramRdData       : out std_logic_vector(c_DataRate               *c_DataWidth     -1 downto 0);

      -- To DDR
      -- DDR3/4 common
      c0_ddr4_reset_n   : out   std_ulogic;
      c0_ddr4_cke       : out   std_logic_vector(c_NbCke*(c_PingPongPhy-c_CkeShared)-1 downto 0);
      c0_ddr4_cs_n      : out   std_logic_vector(c_NbChipSelect*c_PingPongPhy-1 downto 0);
      c0_ddr4_odt       : out   std_logic_vector(c_NbChipSelect*c_PingPongPhy-1 downto 0);
      c0_ddr4_ba        : out   std_logic_vector(c_BankWidth-c_BankGroupWidth-1 downto 0);
      c0_ddr4_dq        : inout std_logic_vector(c_DataWidth-1 downto 0);
      -- DDR4 specific: not used for DDR3
      c0_ddr4_act_n     : out   std_logic;
      c0_ddr4_bg        : out   std_logic_vector(c_BankGroupWidth-1 downto 0);
      c0_ddr4_adr       : out   std_logic_vector(c_PhysAddrWidth-1 downto 0);
      c0_ddr4_ck_p      : out   std_logic_vector(c_NbClkPairs-1 downto 0);
      c0_ddr4_ck_n      : out   std_logic_vector(c_NbClkPairs-1 downto 0);
      c0_ddr4_ck_t      : out   std_logic_vector(c_NbClkPairs-1 downto 0);
      c0_ddr4_ck_c      : out   std_logic_vector(c_NbClkPairs-1 downto 0);
      c0_ddr4_dqs_c     : inout std_logic_vector(c_DqsWidth-1 downto 0) := (others => '0');
      c0_ddr4_dqs_t     : inout std_logic_vector(c_DqsWidth-1 downto 0) := (others => '0');
      c0_ddr4_dm_dbi_n  : inout std_logic_vector(c_DmWidth-1 downto 0);
      -- DDR3 specific: not used for DDR4
      c0_ddr4_ras_n     : out   std_ulogic;
      c0_ddr4_cas_n     : out   std_ulogic;
      c0_ddr4_we_n      : out   std_ulogic;
      c0_ddr4_addr      : out   std_logic_vector(c_PhysAddrWidth-1 downto 0);
      c0_ddr4_dqs_p     : inout std_logic_vector(c_DqsWidth-1 downto 0) := (others => '0');
      c0_ddr4_dqs_n     : inout std_logic_vector(c_DqsWidth-1 downto 0) := (others => '0');
      c0_ddr4_dm        : out   std_logic_vector(c_DmWidth-1 downto 0)
      );
   end component;
end package;

-------------------------------------------------------------------------------
-- E N T I T Y
-------------------------------------------------------------------------------
library IEEE;
use ieee.std_logic_1164.all;

entity SdramPhyUltrascale_0_1 is
      generic(
      c_ResetLevel      : std_logic;
      c_useSRstNotARst  : boolean := true;
      c_BankWidth       : integer;
      c_BankGroupWidth  : integer;
      c_NbChipSelect    : integer;
      c_NbCke           : integer;
      c_DataWidth       : integer;
      c_NbClkPairs      : integer;
      c_PhysAddrWidth   : integer;
      c_DataRate        : integer;
      c_PingPongPhy     : integer;
      c_CkeShared       : integer := 0;
      c_DataBufAdrWidth : integer;
      c_OdtWidth        : integer;
      c_DmWidth         : integer;
      c_DqsWidth        : integer;
      c_DDR             : integer;
      c_DataCmdSlot_0   : integer := 0;  -- Slot Number for Data Commands (Read/Write)
      c_NoDataCmdSlot_0 : integer := 0;  -- Slot Number for Non Data Commands (Active,Refresh)
      c_DataCmdSlot_1   : integer := 0;  -- Slot Number for Data Commands (Read/Write)
      c_NoDataCmdSlot_1 : integer := 0;  -- Slot Number for Non Data Commands (Active,Refresh)
      -- The following parameters are only used for the behavioral phy model
      c_PhyCmdLatency   : integer := 20;
      c_PhyRdLatency    : integer := 22;
      c_BurstLength     : integer;
      c_Registered      : integer;
      c_CASLatency      : integer;
      c_CWLLatency      : integer;
      c_tCK             : integer;
      c_tWR             : integer;
      c_tRFC            : integer;
      c_tRPA            : integer;
      c_DisableDQSn     : integer;
      c_ClkinPeriodMmcm   : integer;
      c_ClkfboutMultMmcm  : integer;
      c_DivclkDivideMmcm  : integer;
      c_Clkout0DivideMmcm : integer;
      c_Clkout1DivideMmcm : integer;
      c_Clkout2DivideMmcm : integer;
      c_SysClkType        : string
      );
   port(
      -- Clock and reset (input to PHY)
      c0_sys_clk_p      : in std_ulogic := '0';      -- Phy differential clock input
      c0_sys_clk_n      : in std_ulogic := '0';      -- Phy differential clock input
      c0_sys_clk_i      : in std_ulogic := '0';      -- Phy no buffer clock input
      sys_rst           : in std_ulogic := '0';      -- Phy reset

      -- Clock and reset (output from PHY to controller/user logic)
      Clk               : out std_ulogic;         -- Controller clock
      sRst              : out std_ulogic;         -- Controller reset
      sRst_o            : out std_ulogic;         -- Controller reset (external to rest of design)
      Clk_2x            : out std_ulogic := '0';  -- Clk_2x   (addn_ui_clkout1 generated by PHY MMCM)
      UsrClk            : out std_ulogic := '0';  -- User Clk (addn_ui_clkout2 generated by PHY MMCM)

      -- Calibration control
      CalibDone         : out std_ulogic;
      DoRIU             : in  std_ulogic;
      Fail_wrDataEn     : out std_logic_vector(c_PingPongPhy-1 downto 0);

      -- From Controller
      SdramCKE          : in  std_logic_vector((c_PingPongPhy-c_CkeShared)*c_DataRate/2-1 downto 0);
      SdramACTn         : in  std_logic_vector(c_DataRate*c_PingPongPhy/2                -1 downto 0) := (others => '0');
      SdramCSn          : in  std_logic_vector(c_DataRate*c_PingPongPhy/2*c_NbChipSelect -1 downto 0);
      SdramRASn         : in  std_logic_vector(c_DataRate*c_PingPongPhy/2                -1 downto 0) := (others => '0');
      SdramCASn         : in  std_logic_vector(c_DataRate*c_PingPongPhy/2                -1 downto 0) := (others => '0');
      SdramWEn          : in  std_logic_vector(c_DataRate*c_PingPongPhy/2                -1 downto 0) := (others => '0');
      SdramODT          : in  std_logic_vector(c_DataRate*c_PingPongPhy/2                -1 downto 0) := (others => '0');
      SdramBank         : in  std_logic_vector(c_DataRate*c_PingPongPhy/2*c_BankWidth    -1 downto 0);
      SdramAddr         : in  std_logic_vector(c_DataRate*c_PingPongPhy/2*c_PhysAddrWidth-1 downto 0);
      SdramWrData       : in  std_logic_vector(c_DataRate                *c_DataWidth    -1 downto 0);
      SdramWrMask       : in  std_logic_vector(c_DataRate                *c_DmWidth      -1 downto 0);
      SdramWrEn         : in  std_logic_vector(           c_PingPongPhy                  -1 downto 0);
      SdramRdEn         : in  std_logic_vector(           c_PingPongPhy                  -1 downto 0);
      SdramCmd          : in  std_logic_vector(           c_PingPongPhy  *3              -1 downto 0);
      SdramSlot         : in  std_logic_vector(           c_PingPongPhy  *2              -1 downto 0);

      -- To Controller
      RdDataValid       : out std_logic_vector(           c_PingPongPhy                  -1 downto 0);
      SdramRdData       : out std_logic_vector(c_DataRate               *c_DataWidth     -1 downto 0);

      -- To DDR
      -- DDR3/4 common
      c0_ddr4_reset_n   : out   std_ulogic;
      c0_ddr4_cke       : out   std_logic_vector(c_NbCke*(c_PingPongPhy-c_CkeShared)-1 downto 0);
      c0_ddr4_cs_n      : out   std_logic_vector(c_NbChipSelect*c_PingPongPhy-1 downto 0);
      c0_ddr4_odt       : out   std_logic_vector(c_NbChipSelect*c_PingPongPhy-1 downto 0);
      c0_ddr4_ba        : out   std_logic_vector(c_BankWidth-c_BankGroupWidth-1 downto 0);
      c0_ddr4_dq        : inout std_logic_vector(c_DataWidth-1 downto 0);
      -- DDR4 specific: not used for DDR3
      c0_ddr4_act_n     : out   std_logic;
      c0_ddr4_bg        : out   std_logic_vector(c_BankGroupWidth-1 downto 0);
      c0_ddr4_adr       : out   std_logic_vector(c_PhysAddrWidth-1 downto 0);
      c0_ddr4_ck_p      : out   std_logic_vector(c_NbClkPairs-1 downto 0);
      c0_ddr4_ck_n      : out   std_logic_vector(c_NbClkPairs-1 downto 0);
      c0_ddr4_ck_t      : out   std_logic_vector(c_NbClkPairs-1 downto 0);
      c0_ddr4_ck_c      : out   std_logic_vector(c_NbClkPairs-1 downto 0);
      c0_ddr4_dqs_c     : inout std_logic_vector(c_DqsWidth-1 downto 0) := (others => '0');
      c0_ddr4_dqs_t     : inout std_logic_vector(c_DqsWidth-1 downto 0) := (others => '0');
      c0_ddr4_dm_dbi_n  : inout std_logic_vector(c_DmWidth-1 downto 0);
      -- DDR3 specific: not used for DDR4
      c0_ddr4_ras_n     : out   std_ulogic;
      c0_ddr4_cas_n     : out   std_ulogic;
      c0_ddr4_we_n      : out   std_ulogic;
      c0_ddr4_addr      : out   std_logic_vector(c_PhysAddrWidth-1 downto 0);
      c0_ddr4_dqs_p     : inout std_logic_vector(c_DqsWidth-1 downto 0) := (others => '0');
      c0_ddr4_dqs_n     : inout std_logic_vector(c_DqsWidth-1 downto 0) := (others => '0');
      c0_ddr4_dm        : out   std_logic_vector(c_DmWidth-1 downto 0)
      );
end SdramPhyUltrascale_0_1;

-------------------------------------------------------------------------------
-- A R C H I T E C T U R E
-------------------------------------------------------------------------------

library IEEE;
use ieee.std_logic_1164.all;

use ieee.std_logic_arith.all;
use ieee.std_logic_unsigned.all;
use work.ToolsPck.all;

architecture rtl of SdramPhyUltrascale_0_1 is

   -------------------------------------------------------------------------------
   -- Functions
   -------------------------------------------------------------------------------
   function f_pp2single(vec_in : std_logic_vector) return std_logic_vector is
      constant c_Length  : natural := vec_in'length/(c_DataRate/2)/c_PingPongPhy;
      variable v_vec_out : std_logic_vector(vec_in'length/c_PingPongPhy-1 downto 0);
   begin
      if c_PingPongPhy = 1 then
         return vec_in;
      else
         for i in 0 to c_DataRate/2-1 loop
            if i = c_DataCmdSlot_0 or i = c_NoDataCmdSlot_0 then
               v_vec_out((i+1)*c_Length-1 downto i*c_Length)   := vec_in((i+1)*c_Length-1 downto i*c_Length);
            else
               v_vec_out((i+1)*c_Length-1 downto i*c_Length)   := vec_in((i+1)*c_Length+vec_in'length/2-1 downto i*c_Length+vec_in'length/2);
            end if;
         end loop;
         return v_vec_out;
      end if;
   end function;

   -------------------------------------------------------------------------------
   -- Constants
   -------------------------------------------------------------------------------
   constant c_CmdLength : natural := 3;
   constant c_CmdNoData : std_logic_vector(c_CmdLength-1 downto 0) := "100"; -- FIXME: these should be placed in a BA317 package
   constant c_CmdRd     : std_logic_vector(c_CmdLength-1 downto 0) := "011"; -- FIXME: these should be placed in a BA317 package
   constant c_CmdWr     : std_logic_vector(c_CmdLength-1 downto 0) := "001"; -- FIXME: these should be placed in a BA317 package

   -------------------------------------------------------------------------------
   -- Signals
   -------------------------------------------------------------------------------
   -- Clk & Reset
   signal Rst_i                      : std_logic := '0';
   signal Clk_i                      : std_logic := '0';

   -- Odt/AuxOut
   signal SdramOdt_i                 : std_logic;
   signal SdramCmd_i_d               : std_logic_vector(2 downto 0) := (others => '0');
   signal SdramCmd_i_dd              : std_logic_vector(2 downto 0) := (others => '0');
   signal SdramCmd_i_ddd             : std_logic_vector(2 downto 0) := (others => '0');

   -- Xilinx PHY signals
   signal mc_ADR                     : std_logic_vector(c_PhysAddrWidth*8-1 downto 0);
   signal mc_BA                      : std_logic_vector((c_BankWidth-c_BankGroupWidth)*8-1 downto 0);
   signal mc_BG                      : std_logic_vector(c_BankGroupWidth*8-1 downto 0);
   signal mc_ACT_n                   : std_logic_vector(7 downto 0);
   signal mc_RAS_n                   : std_logic_vector(7 downto 0);
   signal mc_CAS_n                   : std_logic_vector(7 downto 0);
   signal mc_WE_n                    : std_logic_vector(7 downto 0);
   signal mc_CKE                     : std_logic_vector((c_PingPongPhy-c_CkeShared)*c_NbCke*8-1 downto 0);
   signal mc_CS_n                    : std_logic_vector(c_PingPongPhy*c_NbChipSelect*8-1 downto 0);
   signal mc_ODT                     : std_logic_vector(c_PingPongPhy*c_OdtWidth*8-1 downto 0);

   constant c_mcCASSlotLength        : natural := 2;
   signal mcCasSlot                  : std_logic_vector(c_PingPongPhy*c_mcCASSlotLength-1 downto 0);
   signal mcCasSlot2                 : std_logic_vector(c_PingPongPhy-1 downto 0);
   signal mcRdCAS                    : std_logic_vector(c_PingPongPhy-1 downto 0);
   signal mcWrCAS                    : std_logic_vector(c_PingPongPhy-1 downto 0);
   signal CalibDone_i                : std_logic := '0';
   signal RdDataValid_i              : std_logic_vector(c_PingPongPhy-1 downto 0) := (others=>'0');
   signal gt_data_ready              : std_logic := '0';
   signal DoRIU_active               : std_logic := '0';
   signal wrDataEn_XilPHY            : std_logic_vector(c_PingPongPhy-1 downto 0);
   signal wrDataEn_XilPHY_d          : std_logic_vector(c_PingPongPhy-1 downto 0);
   signal SdramWrEn_d                : std_logic_vector(SdramWrEn'range) := (others=>'0');

   -------------------------------------------------------------------------------
   -- Components
   -------------------------------------------------------------------------------
component vcu_ddr4_controller_v1_0_1_ddr4_0
   port(
      c0_ddr4_ba           : out std_logic_vector(1 downto 0);
      c0_ddr4_dqs_c        : inout std_logic_vector(7 downto 0); -- 7-0
      c0_ddr4_dqs_t        : inout std_logic_vector(7 downto 0); -- 7-0
      c0_ddr4_ck_c         : out std_logic_vector(0 downto 0); -- 0-0
      c0_ddr4_ck_t         : out std_logic_vector(0 downto 0); -- 0-0
      c0_ddr4_adr          : out std_logic_vector(16 downto 0);
      c0_ddr4_cke          : out std_logic_vector(0 downto 0); -- 0-0
      c0_ddr4_odt          : out std_logic_vector(0 downto 0); -- 0-0
      c0_ddr4_reset_n      : out std_ulogic;
      c0_ddr4_dq           : inout std_logic_vector(63 downto 0); -- 63-0
      c0_ddr4_act_n        : out std_ulogic;
      c0_ddr4_bg           : out std_logic_vector(0 downto 0);
	  mc_BG                : in  std_logic_vector(7 downto 0);
      c0_ddr4_dm_dbi_n     : inout std_logic_vector(7 downto 0); -- 7-0
      c0_ddr4_cs_n         : out std_logic_vector(0 downto 0); -- 0-0
      sys_rst              : in  std_ulogic;
      c0_ddr4_ui_clk       : out std_ulogic;
      c0_ddr4_ui_clk_sync_rst : out std_ulogic;
      dbg_clk              : out std_ulogic;
      c0_sys_clk_p         : in  std_ulogic;
      c0_sys_clk_n         : in  std_ulogic;
      addn_ui_clkout2      : out std_ulogic;
      mc_ACT_n             : in  std_logic_vector(7 downto 0);
      mc_ADR               : in  std_logic_vector(135 downto 0);
      mc_BA                : in  std_logic_vector(15 downto 0);
      mc_CKE               : in  std_logic_vector(7 downto 0);
      mc_CS_n              : in  std_logic_vector(7 downto 0);
      mc_ODT               : in  std_logic_vector(7 downto 0);
      
      wrData               : in  std_logic_vector(511 downto 0);
      wrDataEn             : out std_logic_vector(0 downto 0);
      wrDataAddr           : out std_logic_vector(4 downto 0);
      tCWL                 : out std_logic_vector(5 downto 0);
      dBufAdr              : in  std_logic_vector(4 downto 0);
      wrDataMask           : in  std_logic_vector(63 downto 0);
      rdData               : out std_logic_vector(511 downto 0);
      rdDataEn             : out std_logic_vector(0 downto 0);
      rdDataAddr           : out std_logic_vector(4 downto 0);
      per_rd_done          : out std_logic_vector(0 downto 0);
      rmw_rd_done          : out std_logic_vector(0 downto 0);
      rdDataEnd            : out std_logic_vector(0 downto 0);
      c0_init_calib_complete : out std_ulogic;
      mcRdCAS              : in  std_logic_vector(0 downto 0);
      mcWrCAS              : in  std_logic_vector(0 downto 0);
      winRank              : in  std_logic_vector(1 downto 0);
      mcCASSlot            : in  std_logic_vector(1 downto 0);
      mcCASSlot2           : in  std_logic_vector(0 downto 0);
      winInjTxn            : in  std_logic_vector(0 downto 0);
      winRmw               : in  std_logic_vector(0 downto 0);
      winBuf               : in  std_logic_vector(4 downto 0);
      gt_data_ready        : in  std_ulogic;
      dbg_bus              : out std_logic_vector(511 downto 0)
   );
end component;


begin
-------------------------------------------------------------------------------
-- Generation of signals for PHY
-------------------------------------------------------------------------------

   -- Generation of DDR signals on controller input to PHY
   --------------------------------------------------------
   -- There are also 4 command slots in the Ultrascale PHY. We only use slots 0 and 2 for data commands in quad rate.
   -- (see PG150: CAS Command Timing Limitations)
   -- Each command slot has 2 bits per DRAM clock cycle: one for the rising and one for the falling edge.
   -- However, both bits of a command slot should be assigned the same value.
   -- e.g. SdramCSn=0xE, command slot 0 is used -> mc_CS_n bits 0 and 1 are both at '0'


   -- mc_ADR Bits[7:0] corresponds to DRAM address Bit[0] on four DRAM clock cycles
   -- Bits[15:8] corresponds to DRAM address Bit[1] on four DRAM clock cycles, etc.
   p_mc_ADR: process(SdramAddr)
   begin
      for i in 0 to c_DataRate/2-1 loop
         for j in 0 to c_PhysAddrWidth-1 loop
            mc_ADR(j*8+2*i+1 downto j*8+2*i) <= (others=>f_pp2single(SdramAddr)(c_PhysAddrWidth*i+j));
         end loop;
      end loop;
   end process;

   g_mc_BA_DDR3: if c_DDR=3 generate
      -- mc_BA Bits[7:0] corresponds to DRAM bank address Bit[0] on four DRAM clock cycles
      -- Bits[15:8] corresponds to DRAM bank address Bit[1] on four DRAM clock cycles, etc.
      p_mc_BA: process(SdramBank)
      begin
         for i in 0 to c_DataRate/2-1 loop
            for j in 0 to c_BankWidth-1 loop
               mc_BA(j*8+2*i+1 downto j*8+2*i)  <= (others=>f_pp2single(SdramBank)(c_BankWidth*i+j));
            end loop;
         end loop;
      end process;
   end generate;

   -- Generate Bank Group for DDR4
   -- For the moment, no difference is made between bank groups and banks
   g_mc_BG: if c_DDR=4 generate
      -- mc_BA Bits[7:0] corresponds to DRAM bank address Bit[0] on four DRAM clock cycles
      -- Bits[15:8] corresponds to DRAM bank address Bit[1] on four DRAM clock cycles, etc.
      p_mc_BA: process(SdramBank)
      begin
         for i in 0 to c_DataRate/2-1 loop
            for j in 0 to c_BankWidth-c_BankGroupWidth-1 loop
               mc_BA(j*8+2*i+1 downto j*8+2*i)  <= (others=>f_pp2single(SdramBank)(c_BankWidth*i+j));
            end loop;
         end loop;
      end process;

      p_mc_BG: process(SdramBank)
      begin
         for i in 0 to c_DataRate/2-1 loop
            for j in 0 to c_BankGroupWidth-1 loop
               mc_BG(j*8+2*i+1 downto j*8+2*i)  <= (others=>f_pp2single(SdramBank)(c_BankWidth*i+c_BankWidth-c_BankGroupWidth+j));
            end loop;
         end loop;
      end process;
   end generate;

   p_mc_CS_n: process(SdramCSn)
   begin
      for i in SdramCSn'range loop
         mc_CS_n(2*i+1 downto 2*i)  <= (others=>SdramCSn(i));
      end loop;
   end process;

   p_mc_ODT_n: process(SdramODT)
   begin
      for i in SdramODT'range loop
         mc_ODT(2*i+1 downto 2*i)   <= (others=>SdramODT(i));
      end loop;
   end process;

   -- Generate ACTn for DDR4
   g_mc_ACT_n: if c_DDR=4 generate
      p_mc_ACT_n: process(SdramACTn)
      begin
         for i in 0 to c_DataRate/2-1 loop
            mc_ACT_n(2*i+1 downto 2*i) <= (others=>f_pp2single(SdramACTn)(i));
         end loop;
      end process;
   end generate;

   -- Generate CSn, RASn and WEn for DDR3
   g_mc_RAS_CAS_WE: if c_DDR=3 generate
      p_mc_RAS_CAS_WE: process(SdramRASn, SdramCASn, SdramWEn)
      begin
         for i in 0 to c_DataRate/2-1 loop
            mc_RAS_n(2*i+1 downto 2*i) <= (others=>f_pp2single(SdramRASn)(i));
            mc_CAS_n(2*i+1 downto 2*i) <= (others=>f_pp2single(SdramCASn)(i));
            mc_WE_n(2*i+1 downto 2*i)  <= (others=>f_pp2single(SdramWEn)(i));
         end loop;
      end process;
   end generate;

   p_mc_CKE: process(SdramCKE)
   begin
      for i in SdramCKE'range loop
         mc_CKE(2*i+1 downto 2*i)   <= (others=>SdramCKE(i));
      end loop;
   end process;

   p_gt_data_ready : process(Rst_i, Clk_i)
   procedure Reset is
   begin
      gt_data_ready  <= '0';
      DoRIU_active   <= '0';
   end procedure;
   begin
      if not (c_useSRstNotARst) and Rst_i = c_ResetLevel then
         Reset;
      elsif rising_edge(Clk_i) then
         if DoRIU = '1' then
            DoRIU_active   <= '1';
         elsif gt_data_ready = '1' then
            DoRIU_active   <= '0';
         end if;
         gt_data_ready <= RdDataValid_i(0) and DoRIU_active;

         -- FIXME: is a reset really required here? in principle a false gt_data_ready could be active at startup, interfering with calibration
         if c_useSRstNotARst and Rst_i = c_ResetLevel then
            Reset;
         end if;
      end if;
   end process p_gt_data_ready;

-------------------------------------------------------------------------------
-- Xilinx Ultrascale Phy
-------------------------------------------------------------------------------

i_vcu_ddr4_controller_v1_0_1_ddr4_0 : vcu_ddr4_controller_v1_0_1_ddr4_0
port map(
   c0_ddr4_ba           => c0_ddr4_ba,
   c0_ddr4_dqs_c        => c0_ddr4_dqs_c,
   c0_ddr4_dqs_t        => c0_ddr4_dqs_t,
   c0_ddr4_ck_c         => c0_ddr4_ck_c,
   c0_ddr4_ck_t         => c0_ddr4_ck_t,
   c0_ddr4_adr          => c0_ddr4_adr,
   c0_ddr4_cke          => c0_ddr4_cke,
   c0_ddr4_odt          => c0_ddr4_odt,
   c0_ddr4_reset_n      => c0_ddr4_reset_n,
   c0_ddr4_dq           => c0_ddr4_dq,
   c0_ddr4_act_n        => c0_ddr4_act_n,
   c0_ddr4_bg           => c0_ddr4_bg,
   c0_ddr4_dm_dbi_n     => c0_ddr4_dm_dbi_n,
   c0_ddr4_cs_n         => c0_ddr4_cs_n,
   sys_rst              => sys_rst,
   c0_ddr4_ui_clk       => Clk_i,
   c0_ddr4_ui_clk_sync_rst => Rst_i,
   dbg_clk              => open,
   c0_sys_clk_p         => c0_sys_clk_p,
   c0_sys_clk_n         => c0_sys_clk_n,
   addn_ui_clkout2      => UsrClk,
   mc_ACT_n             => mc_ACT_n,
   mc_ADR               => mc_ADR,
   mc_BA                => mc_BA,
   mc_CKE               => mc_CKE,
   mc_CS_n              => mc_CS_n,
   mc_ODT               => mc_ODT,
   mc_BG                => mc_BG,
   wrData               => SdramWrData,
   wrDataEn             => wrDataEn_XilPHY,
   wrDataAddr           => open,
   tCWL                 => open,
   dBufAdr              => (others=>'0'),
   wrDataMask           => SdramWrMask,
   rdData               => SdramRdData,
   rdDataEn             => RdDataValid_i,
   rdDataAddr           => open,
   per_rd_done          => open,
   rmw_rd_done          => open,
   rdDataEnd            => open,
   c0_init_calib_complete => CalibDone_i,
   mcRdCAS              => mcRdCAS,
   mcWrCAS              => mcWrCAS,
   winRank              => (others=>'0'),
   mcCASSlot            => mcCASSlot,
   mcCASSlot2           => mcCASSlot2,
   winInjTxn            => (others=>'0'),
   winRmw               => (others=>'0'),
   winBuf               => (others=>'0'),
   gt_data_ready        => gt_data_ready,
   dbg_bus              => open
);


-------------------------------------------------------------------------------
-- Assign others outputs
-------------------------------------------------------------------------------
   CalibDone <= CalibDone_i;
   RdDataValid <= RdDataValid_i;

   p_mcCasSlot: process(CalibDone_i)
      variable v_DataCmdSlot : std_logic_vector(c_mcCASSlotLength-1 downto 0);
   begin
      if CalibDone_i = '0' then
         mcCasSlot  <= (others => '0');
         mcCasSlot2 <= (others => '0');
      else
         for i in 0 to c_PingPongPhy-1 loop
            if i = 0 then
               v_DataCmdSlot := conv_std_logic_vector(c_DataCmdSlot_0, v_DataCmdSlot'length);
            else
               v_DataCmdSlot := conv_std_logic_vector(c_DataCmdSlot_1, v_DataCmdSlot'length);
            end if;
            mcCasSlot(c_mcCASSlotLength*(i+1)-1 downto c_mcCASSlotLength*i) <= v_DataCmdSlot;
            mcCasSlot2(i)                   <= v_DataCmdSlot(v_DataCmdSlot'high);
         end loop;
      end if;
   end process;

   -- Generate mcRdCAS and mcWrCAS
   p_mcCas: process(SdramCmd)
      variable v_Cmd : std_logic_vector(c_CmdLength-1 downto 0);
   begin
      mcRdCAS <= (others => '0');
      mcWrCAS <= (others => '0');
      for i in 0 to c_PingPongPhy-1 loop
         v_Cmd := SdramCmd((i+1)*c_CmdLength-1 downto i*c_CmdLength);
         assert (CalibDone_i = '0' and v_Cmd /= c_CmdRd and v_Cmd /= c_CmdWr) or CalibDone_i /= '0'
            report "No commands can be provided to phy before calibration is complete."
            severity failure;
         if    v_Cmd = c_CmdRd then
            mcRdCAS(i) <= '1';
         elsif v_Cmd = c_CmdWr then
            mcWrCAS(i) <= '1';
         end if;
      end loop;
   end process;

   Clk       <= Clk_i;
   sRst      <= Rst_i;
   sRst_o    <= Rst_i;

-------------------------------------------------------------------------------
-- Verification: can be removed if wrDataEn is used to fetch data
-------------------------------------------------------------------------------
   p_wrDataEn_synth : process(Rst_i, Clk_i)
      procedure Reset is
      begin
         Fail_wrDataEn  <= (others=>'0');
      end procedure;
      begin
      if not (c_useSRstNotARst) and Rst_i = c_ResetLevel then
            Reset;
         elsif rising_edge(Clk_i) then
            for i in c_PingPongPhy-1 downto 0 loop
               if SdramWrEn(i) /= wrDataEn_XilPHY(i) then
                  Fail_wrDataEn(i)  <= '1';
               end if;
            end loop;

            if c_useSRstNotARst and Rst_i = c_ResetLevel then
               Reset;
            end if;
         end if;
      end process p_wrDataEn_synth;

-------------------------------------------------------------------------------
-- Simulation specific
-------------------------------------------------------------------------------
   -- synthesis translate_off

   -- The WrEn is now an output signal from the PHY, instead of signal generated by the controller
   -- Check if SdramWrEn arrives on the same clock cycle as WrEn from PHY asserts. The wrDataEn from the phy needs to be
   -- clocked as the model introduces some delay, creating a mismatch when comparing at the clock edge
   p_wrDataEn_XilPHY : process(Rst_i, Clk_i)
      procedure proc_reset is
      begin
        wrDataEn_XilPHY_d <= (others=>'0');
        SdramWrEn_d       <= (others=>'0');
      end procedure;
   begin
      if rising_edge(Clk_i) then
         wrDataEn_XilPHY_d <= wrDataEn_XilPHY;
         SdramWrEn_d       <= SdramWrEn;

         if Rst_i = c_ResetLevel then
            proc_reset;
         else
            assert wrDataEn_XilPHY_d = SdramWrEn_d
               report "SdramWrEn should assert exactly one clock cycle after WrEn from PHY asserts. Adapt parameter phyPipe in the controller generation script"
               severity failure;
         end if;
      end if;
   end process;

   -- synthesis translate_on

end rtl;
